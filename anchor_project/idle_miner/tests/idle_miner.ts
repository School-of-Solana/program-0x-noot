import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import {
  TOKEN_PROGRAM_ID,
  createMint,
  mintTo,
  getAccount,
  ACCOUNT_SIZE,
  createInitializeAccountInstruction,
} from "@solana/spl-token";
import {
  PublicKey,
  SystemProgram,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import * as assert from "assert";

// Type generated by Anchor (after `anchor build`)
import { IdleMiner } from "../target/types/idle_miner";

describe("idle_miner", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const program = anchor.workspace.IdleMiner as Program<IdleMiner>;
  const connection = provider.connection;
  const admin = provider.wallet as anchor.Wallet;

  // Shared accounts across tests (local validator only)
  let rewardMint: PublicKey;
  let rewardVault: PublicKey;
  let gameConfigPda: PublicKey;

  // Config values used in initialize_game (small interval so tests are fast)
  const entryFeeLamports = new anchor.BN(1 * LAMPORTS_PER_SOL); // 1 SOL
  const baseRate = new anchor.BN(1000); // 1000 score per interval
  const intervalSeconds = new anchor.BN(1); // 1 second interval
  const milestoneScore = new anchor.BN(1000); // 1000 score to hit milestone
  const rewardPerMilestone = new anchor.BN(1_000_000_000_000); // 1000 tokens (9 decimals)

  before("set up reward mint and PDA-owned vault", async () => {
    // Airdrop to admin on localnet just in case
    const sig = await connection.requestAirdrop(
      admin.publicKey,
      5 * LAMPORTS_PER_SOL
    );
    await connection.confirmTransaction(sig);

    // 1) Create test reward mint
    rewardMint = await createMint(
      connection,
      admin.payer,           // fee payer
      admin.publicKey,       // mint authority
      null,                  // freeze authority
      9                      // decimals
    );

    // 2) Derive game_config PDA (same seeds as in Rust)
    [gameConfigPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("game-config")],
      program.programId
    );

    // 3) Manually create a token account whose owner is the game_config PDA
    const rewardVaultKeypair = anchor.web3.Keypair.generate();

    const lamportsForRent =
      await connection.getMinimumBalanceForRentExemption(ACCOUNT_SIZE);

    const createIx = SystemProgram.createAccount({
      fromPubkey: admin.publicKey,
      newAccountPubkey: rewardVaultKeypair.publicKey,
      space: ACCOUNT_SIZE,
      lamports: lamportsForRent,
      programId: TOKEN_PROGRAM_ID,
    });

    const initIx = createInitializeAccountInstruction(
      rewardVaultKeypair.publicKey, // token account pubkey
      rewardMint,                   // which mint
      gameConfigPda                 // owner = game_config PDA
    );

    const tx = new anchor.web3.Transaction().add(createIx, initIx);

    await provider.sendAndConfirm(tx, [rewardVaultKeypair]);

    rewardVault = rewardVaultKeypair.publicKey;

    // 4) Fund vault with a lot of tokens
    await mintTo(
      connection,
      admin.payer,
      rewardMint,
      rewardVault,
      admin.publicKey,               // mint authority
      1_000_000_000_000_000n        // 1,000,000 tokens with 9 decimals
    );
  });

  it("initialize_game: creates config (happy) and fails on second init (unhappy)", async () => {
    // HAPPY PATH: first initialize should succeed
    await program.methods
      .initializeGame(
        entryFeeLamports,
        baseRate,
        intervalSeconds,
        milestoneScore,
        rewardPerMilestone
      )
      .accounts({
        admin: admin.publicKey,
        gameConfig: gameConfigPda,
        rewardMint,
        rewardVault,
        systemProgram: SystemProgram.programId,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .rpc();

    // Check GameConfig was created and fields set
    const config = await program.account.gameConfig.fetch(gameConfigPda);
    assert.strictEqual(
      config.admin.toBase58(),
      admin.publicKey.toBase58(),
      "admin should match"
    );
    assert.strictEqual(
      config.entryFeeLamports.toString(),
      entryFeeLamports.toString()
    );
    assert.strictEqual(
      config.baseRate.toString(),
      baseRate.toString()
    );
    assert.strictEqual(
      config.intervalSeconds.toString(),
      intervalSeconds.toString()
    );
    assert.strictEqual(
      config.milestoneScore.toString(),
      milestoneScore.toString()
    );
    assert.strictEqual(
      config.rewardPerMilestone.toString(),
      rewardPerMilestone.toString()
    );
    assert.strictEqual(
      config.rewardMint.toBase58(),
      rewardMint.toBase58()
    );
    assert.strictEqual(
      config.rewardVault.toBase58(),
      rewardVault.toBase58()
    );

    // UNHAPPY PATH: second initialize should fail (account already in use)
    let threw = false;
    try {
      await program.methods
        .initializeGame(
          entryFeeLamports,
          baseRate,
          intervalSeconds,
          milestoneScore,
          rewardPerMilestone
        )
        .accounts({
          admin: admin.publicKey,
          gameConfig: gameConfigPda,
          rewardMint,
          rewardVault,
          systemProgram: SystemProgram.programId,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .rpc();
    } catch (_err) {
      threw = true;
    }
    assert.ok(threw, "Second initialize_game should fail");
  });

  it("create_player: creates a player (happy) and fails on duplicate (unhappy)", async () => {
    const playerKeypair = anchor.web3.Keypair.generate();

    // Airdrop to cover entry fee
    const sig = await connection.requestAirdrop(
      playerKeypair.publicKey,
      2 * LAMPORTS_PER_SOL
    );
    await connection.confirmTransaction(sig);

    const [playerPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("player"), playerKeypair.publicKey.toBuffer()],
      program.programId
    );

    // HAPPY PATH: first create_player works
    await program.methods
      .createPlayer()
      .accounts({
        authority: playerKeypair.publicKey,
        gameConfig: gameConfigPda,
        player: playerPda,
        systemProgram: SystemProgram.programId,
      })
      .signers([playerKeypair])
      .rpc();

    const playerAccount = await program.account.player.fetch(playerPda);
    assert.strictEqual(
      playerAccount.authority.toBase58(),
      playerKeypair.publicKey.toBase58()
    );
    assert.strictEqual(
      playerAccount.miningRate.toString(),
      baseRate.toString()
    );

    // UNHAPPY PATH: creating same player again should fail (PDA already exists)
    let threw = false;
    try {
      await program.methods
        .createPlayer()
        .accounts({
          authority: playerKeypair.publicKey,
          gameConfig: gameConfigPda,
          player: playerPda,
          systemProgram: SystemProgram.programId,
        })
        .signers([playerKeypair])
        .rpc();
    } catch (_err) {
      threw = true;
    }
    assert.ok(threw, "Second create_player for same authority should fail");
  });

  it("claim_reward: first claim succeeds, immediate second claim fails (happy + unhappy)", async () => {
    const playerKeypair = anchor.web3.Keypair.generate();

    // Fund player
    const sig = await connection.requestAirdrop(
      playerKeypair.publicKey,
      2 * LAMPORTS_PER_SOL
    );
    await connection.confirmTransaction(sig);

    const [playerPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("player"), playerKeypair.publicKey.toBuffer()],
      program.programId
    );

    // Create player
    await program.methods
      .createPlayer()
      .accounts({
        authority: playerKeypair.publicKey,
        gameConfig: gameConfigPda,
        player: playerPda,
        systemProgram: SystemProgram.programId,
      })
      .signers([playerKeypair])
      .rpc();

    // Create player's reward token account (correct mint)
    const playerTokenAccount = await (async () => {
      const kp = anchor.web3.Keypair.generate();
      const lamports =
        await connection.getMinimumBalanceForRentExemption(ACCOUNT_SIZE);
      const createIx = SystemProgram.createAccount({
        fromPubkey: admin.publicKey,
        newAccountPubkey: kp.publicKey,
        space: ACCOUNT_SIZE,
        lamports,
        programId: TOKEN_PROGRAM_ID,
      });
      const initIx = createInitializeAccountInstruction(
        kp.publicKey,
        rewardMint,
        playerKeypair.publicKey
      );
      const tx = new anchor.web3.Transaction().add(createIx, initIx);
      await provider.sendAndConfirm(tx, [kp]);
      return kp.publicKey;
    })();

    // Wait so mining can accumulate to at least one milestone
    await new Promise((resolve) => setTimeout(resolve, 1500));

    // HAPPY: first claim should succeed
    await program.methods
      .claimReward()
      .accounts({
        authority: playerKeypair.publicKey,
        gameConfig: gameConfigPda,
        player: playerPda,
        rewardVault,
        playerTokenAccount,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .signers([playerKeypair])
      .rpc();

    const afterFirst = await getAccount(connection, playerTokenAccount);
    assert.ok(
      afterFirst.amount > 0n,
      "Player should receive some reward tokens on first claim"
    );

    // UNHAPPY: immediately try to claim again â€“ not enough new score has accumulated
    let threw = false;
    try {
      await program.methods
        .claimReward()
        .accounts({
          authority: playerKeypair.publicKey,
          gameConfig: gameConfigPda,
          player: playerPda,
          rewardVault,
          playerTokenAccount,
          tokenProgram: TOKEN_PROGRAM_ID,
        })
        .signers([playerKeypair])
        .rpc();
    } catch (_err) {
      threw = true;
    }

    assert.ok(
      threw,
      "Second claim_reward should fail when new score hasn't accumulated yet"
    );
  });

  it("upgrade_miner: fails if score too low (unhappy)", async () => {
    const playerKeypair = anchor.web3.Keypair.generate();

    // Fund player
    const sig = await connection.requestAirdrop(
      playerKeypair.publicKey,
      2 * LAMPORTS_PER_SOL
    );
    await connection.confirmTransaction(sig);

    const [playerPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("player"), playerKeypair.publicKey.toBuffer()],
      program.programId
    );

    // Create player
    await program.methods
      .createPlayer()
      .accounts({
        authority: playerKeypair.publicKey,
        gameConfig: gameConfigPda,
        player: playerPda,
        systemProgram: SystemProgram.programId,
      })
      .signers([playerKeypair])
      .rpc();

    // UNHAPPY: immediately try to upgrade (no score yet)
    let threw = false;
    try {
      await program.methods
        .upgradeMiner()
        .accounts({
          authority: playerKeypair.publicKey,
          gameConfig: gameConfigPda,
          player: playerPda,
        })
        .signers([playerKeypair])
        .rpc();
    } catch (_err) {
      threw = true;
    }
    assert.ok(threw, "upgrade_miner should fail with insufficient score");
  });

  it("upgrade_miner: increases mining rate when enough score (happy)", async () => {
    const playerKeypair = anchor.web3.Keypair.generate();

    // Fund player
    const sig = await connection.requestAirdrop(
      playerKeypair.publicKey,
      2 * LAMPORTS_PER_SOL
    );
    await connection.confirmTransaction(sig);

    const [playerPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("player"), playerKeypair.publicKey.toBuffer()],
      program.programId
    );

    // Create player
    await program.methods
      .createPlayer()
      .accounts({
        authority: playerKeypair.publicKey,
        gameConfig: gameConfigPda,
        player: playerPda,
        systemProgram: SystemProgram.programId,
      })
      .signers([playerKeypair])
      .rpc();

    // Wait a bit so score can accumulate
    await new Promise((resolve) => setTimeout(resolve, 1500));

    const before = await program.account.player.fetch(playerPda);
    const beforeRate = before.miningRate.toNumber();

    // HAPPY: upgrade miner
    await program.methods
      .upgradeMiner()
      .accounts({
        authority: playerKeypair.publicKey,
        gameConfig: gameConfigPda,
        player: playerPda,
      })
      .signers([playerKeypair])
      .rpc();

    const after = await program.account.player.fetch(playerPda);
    const afterRate = after.miningRate.toNumber();

    assert.ok(
      afterRate > beforeRate,
      `mining rate should increase after upgrade (before=${beforeRate}, after=${afterRate})`
    );
  });
});
